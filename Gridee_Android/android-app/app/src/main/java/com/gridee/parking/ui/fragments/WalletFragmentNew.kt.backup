package com.gridee.parking.ui.fragments

import android.content.Intent
import android.text.TextWatcher
import android.text.Editable
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import com.gridee.parking.R
import com.gridee.parking.data.api.ApiClient
import com.gridee.parking.data.model.WalletTransaction
import com.gridee.parking.databinding.FragmentWalletNewBinding
import com.gridee.parking.databinding.BottomSheetTopUpSimpleBinding
import com.gridee.parking.ui.activities.TransactionHistoryActivity
import com.gridee.parking.ui.adapters.Transaction
import com.gridee.parking.ui.adapters.TransactionType
import com.gridee.parking.ui.adapters.TransactionsAdapter
import com.gridee.parking.ui.base.BaseTabFragment
import com.google.android.material.bottomsheet.BottomSheetDialog
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*

class WalletFragmentNew : BaseTabFragment<FragmentWalletNewBinding>() {

    private lateinit var transactionsAdapter: TransactionsAdapter
    private var currentBalance = 0.0
    private var userTransactions = mutableListOf<Transaction>()

    override fun getViewBinding(inflater: LayoutInflater, container: ViewGroup?): FragmentWalletNewBinding {
        return FragmentWalletNewBinding.inflate(inflater, container, false)
    }

    override fun getScrollableView(): View? {
        return try {
            binding.scrollContent
        } catch (e: IllegalStateException) {
            null
        }
    }

    override fun setupUI() {
        setupRecyclerView()
        setupClickListeners()
        loadWalletData()
    }

    private fun setupRecyclerView() {
        transactionsAdapter = TransactionsAdapter(emptyList())
        
        binding.rvTransactions.apply {
            layoutManager = LinearLayoutManager(requireContext())
            adapter = transactionsAdapter
        }
    }

    private fun setupClickListeners() {
        binding.tvViewAll.setOnClickListener {
            val intent = Intent(requireContext(), TransactionHistoryActivity::class.java)
            startActivity(intent)
        }
        
        binding.btnAddMoney.setOnClickListener {
            android.util.Log.d("WalletFragmentNew", "Add money button clicked")
            showTopUpDialog()
        }
        
        // Quick Add buttons - direct top-up
        binding.btnQuickAdd10.setOnClickListener {
            processTopUp(10.0)
        }
        
        binding.btnQuickAdd20.setOnClickListener {
            processTopUp(20.0)
        }
        
        binding.btnQuickAdd100.setOnClickListener {
            processTopUp(100.0)
        }
    }

    private fun loadWalletData() {
        binding.progressLoading.visibility = View.VISIBLE
        
        val userId = getUserId()
        if (userId == null) {
            showToast("Please login to view wallet")
            binding.progressLoading.visibility = View.GONE
            return
        }
        
        // Load and display user name on credit card
        loadUserName()

        lifecycleScope.launch {
            try {
                android.util.Log.d("WalletFragmentNew", "Loading wallet data for user: $userId")
                
                // Load wallet details (balance + transactions)
                val response = ApiClient.apiService.getWalletDetails(userId)
                android.util.Log.d("WalletFragmentNew", "Wallet API response: ${response.code()}")
                
                if (response.isSuccessful) {
                    val walletDetails = response.body()
                    android.util.Log.d("WalletFragmentNew", "Wallet details: balance=${walletDetails?.balance}, transactions=${walletDetails?.transactions?.size}")
                    
                    if (walletDetails != null) {
                        // Update balance
                        currentBalance = walletDetails.balance ?: 0.0
                        updateBalanceDisplay()
                        
                        // Convert backend transactions to UI transactions
                        val backendTransactions = walletDetails.transactions ?: emptyList()
                        userTransactions.clear()
                        
                        // Convert and sort transactions by timestamp (newest first)
                        val convertedTransactions = backendTransactions.map { convertToUITransaction(it) }
                        userTransactions.addAll(convertedTransactions.sortedByDescending { it.timestamp })
                        
                        // Update UI
                        updateTransactionsDisplay()
                        android.util.Log.d("WalletFragmentNew", "Successfully loaded ${backendTransactions.size} transactions")
                    } else {
                        // Empty response - show zero balance and no transactions
                        currentBalance = 0.0
                        updateBalanceDisplay()
                        userTransactions.clear()
                        updateTransactionsDisplay()
                        showToast("No wallet data found")
                    }
                } else {
                    // API error - try to get transactions separately and show zero balance
                    handleApiError(response.code(), userId)
                }
                
            } catch (e: Exception) {
                // Network error - try fallback API call
                handleNetworkError(e, userId)
            } finally {
                binding.progressLoading.visibility = View.GONE
            }
        }
    }

    private fun handleApiError(errorCode: Int, userId: String) {
        lifecycleScope.launch {
            try {
                // Try to get just the transactions if wallet details failed
                val transactionResponse = ApiClient.apiService.getWalletTransactions(userId)
                if (transactionResponse.isSuccessful) {
                    val backendTransactions = transactionResponse.body() ?: emptyList()
                    userTransactions.clear()
                    
                    // Convert and sort transactions by timestamp (newest first)
                    val convertedTransactions = backendTransactions.map { convertToUITransaction(it) }
                    userTransactions.addAll(convertedTransactions.sortedByDescending { it.timestamp })
                    
                    // Calculate balance from transactions if possible
                    currentBalance = if (backendTransactions.isNotEmpty()) {
                        backendTransactions.lastOrNull()?.balanceAfter ?: 0.0
                    } else {
                        0.0
                    }
                    
                    updateBalanceDisplay()
                    updateTransactionsDisplay()
                    showToast("Wallet balance unavailable, showing transactions")
                } else {
                    // Both APIs failed - show zero balance
                    showRealEmptyState()
                    showToast("Error loading wallet data (Error: $errorCode)")
                }
            } catch (e: Exception) {
                showRealEmptyState()
                showToast("Error loading wallet data: ${e.message}")
            }
        }
    }

    private fun handleNetworkError(exception: Exception, userId: String) {
        // Show empty state with zero balance for network errors
        showRealEmptyState()
        showToast("Network error: ${exception.message}")
    }

    private fun showRealEmptyState() {
        currentBalance = 0.0
        updateBalanceDisplay()
        userTransactions.clear()
        updateTransactionsDisplay()
    }

    private fun updateBalanceDisplay() {
        binding.tvBalanceAmount.text = "₹${String.format("%.2f", currentBalance)}"
    }

    private fun updateTransactionsDisplay() {
        if (userTransactions.isEmpty()) {
            binding.rvTransactions.visibility = View.GONE
            binding.layoutEmptyState.visibility = View.VISIBLE
        } else {
            binding.rvTransactions.visibility = View.VISIBLE
            binding.layoutEmptyState.visibility = View.GONE
            
            // Sort transactions by timestamp (newest first) and show only recent 5
            val sortedTransactions = userTransactions.sortedByDescending { it.timestamp }
            val recentTransactions = sortedTransactions.take(5)
            
            android.util.Log.d("WalletFragmentNew", "Displaying ${recentTransactions.size} recent transactions out of ${userTransactions.size} total")
            transactionsAdapter.updateTransactions(recentTransactions)
        }
    }

    private fun loadSampleData() {
        // This method is kept for testing purposes only
        // In production, this should not be called - real data should always be used
        android.util.Log.w("WalletFragmentNew", "Using sample data - this should not happen in production!")
        
        currentBalance = 0.0
        updateBalanceDisplay()
        userTransactions.clear()
        updateTransactionsDisplay()
        showToast("No real wallet data available")
    }

    private fun convertToUITransaction(backendTransaction: WalletTransaction): Transaction {
        // Use ISO 8601 format with timezone support for better date parsing
        val dateFormat = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", Locale.getDefault())
        val fallbackFormat = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.getDefault())
        val simpleDateFormat = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
        
        // Set timezone to handle UTC correctly
        dateFormat.timeZone = TimeZone.getTimeZone("UTC")
        fallbackFormat.timeZone = TimeZone.getDefault()
        
        // Parse timestamp or use current date as fallback
        val timestamp = try {
            if (backendTransaction.timestamp != null) {
                // Try multiple date formats
                try {
                    dateFormat.parse(backendTransaction.timestamp) ?: Date()
                } catch (e: Exception) {
                    try {
                        fallbackFormat.parse(backendTransaction.timestamp) ?: Date()
                    } catch (e2: Exception) {
                        // Try simple date format as last resort
                        simpleDateFormat.parse(backendTransaction.timestamp) ?: Date()
                    }
                }
            } else {
                Date()
            }
        } catch (e: Exception) {
            android.util.Log.w("WalletFragmentNew", "Failed to parse timestamp: ${backendTransaction.timestamp}", e)
            Date()
        }
        
        // Map transaction type and handle amount correctly
        val transactionType = when (backendTransaction.type?.uppercase()) {
            "CREDIT" -> TransactionType.TOP_UP
            "DEBIT" -> TransactionType.PARKING_PAYMENT
            "REFUND" -> TransactionType.REFUND
            "BONUS" -> TransactionType.BONUS
            else -> TransactionType.PARKING_PAYMENT
        }
        
        // Ensure proper amount handling:
        // CREDIT transactions should be positive
        // DEBIT transactions should be negative
        val amount = backendTransaction.amount ?: 0.0
        val displayAmount = when (backendTransaction.type?.uppercase()) {
            "DEBIT" -> if (amount > 0) -amount else amount  // Make sure debits are negative
            "CREDIT", "REFUND", "BONUS" -> if (amount < 0) -amount else amount  // Make sure credits are positive
            else -> amount
        }
        
        android.util.Log.d("WalletFragmentNew", "Converting transaction: type=${backendTransaction.type}, originalAmount=$amount, displayAmount=$displayAmount")
        
        return Transaction(
            id = backendTransaction.id ?: "Unknown",
            type = transactionType,
            amount = displayAmount,
            description = backendTransaction.description ?: "Transaction",
            timestamp = timestamp,
            balanceAfter = backendTransaction.balanceAfter ?: 0.0
        )
    }

    private fun showTopUpDialog() {
        try {
            android.util.Log.d("WalletFragmentNew", "showTopUpDialog called")
            
            val bottomSheetDialog = BottomSheetDialog(requireContext())
            val bottomSheetBinding = BottomSheetTopUpSimpleBinding.inflate(layoutInflater)
            bottomSheetDialog.setContentView(bottomSheetBinding.root)
            
            android.util.Log.d("WalletFragmentNew", "Bottom sheet dialog created")
            
            // Set current balance
            bottomSheetBinding.tvCurrentBalance.text = "₹${String.format("%.2f", currentBalance)}"
            
            // Setup click listeners for quick amount buttons (only 3 buttons now)
            bottomSheetBinding.btnAmount50.setOnClickListener {
                bottomSheetBinding.etAmount.setText("50")
                updateAddButtonState(bottomSheetBinding)
            }
            
            bottomSheetBinding.btnAmount100.setOnClickListener {
                bottomSheetBinding.etAmount.setText("100")
                updateAddButtonState(bottomSheetBinding)
            }
            
    private fun showTopUpDialog() {
        try {
            android.util.Log.d("WalletFragmentNew", "showTopUpDialog called")
            
            val bottomSheetDialog = BottomSheetDialog(requireContext())
            val bottomSheetBinding = BottomSheetTopUpSimpleBinding.inflate(layoutInflater)
            bottomSheetDialog.setContentView(bottomSheetBinding.root)
            
            android.util.Log.d("WalletFragmentNew", "Bottom sheet dialog created")
            
            // Set current balance
            bottomSheetBinding.tvCurrentBalance.text = "Balance: ₹${String.format("%.2f", currentBalance)}"
            
            // Setup click listeners for quick amount buttons (only 3 buttons now)
            bottomSheetBinding.btnAmount50.setOnClickListener {
                bottomSheetBinding.etAmount.setText("50")
                updateAddButtonState(bottomSheetBinding)
            }
            
            bottomSheetBinding.btnAmount100.setOnClickListener {
                bottomSheetBinding.etAmount.setText("100")
                updateAddButtonState(bottomSheetBinding)
            }
            
            bottomSheetBinding.btnAmount200.setOnClickListener {
                bottomSheetBinding.etAmount.setText("200")
                updateAddButtonState(bottomSheetBinding)
            }
            
            // Setup payment method selection (only UPI and Card)
            var selectedPaymentMethod = "UPI" // Default selection
            
            bottomSheetBinding.layoutUpi.setOnClickListener {
                selectPaymentMethod(bottomSheetBinding, "UPI")
                selectedPaymentMethod = "UPI"
            }
            
            bottomSheetBinding.layoutCard.setOnClickListener {
                selectPaymentMethod(bottomSheetBinding, "CARD")
                selectedPaymentMethod = "CARD"
            }
            
            // Setup text change listener for amount input
            bottomSheetBinding.etAmount.addTextChangedListener(object : TextWatcher {
                override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
                override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}
                override fun afterTextChanged(s: Editable?) {
                    updateAddButtonState(bottomSheetBinding)
                }
            })
            
            // Close button
            bottomSheetBinding.btnClose.setOnClickListener {
                bottomSheetDialog.dismiss()
            }
            
            // Add money button
            bottomSheetBinding.btnAddMoneyConfirm.setOnClickListener {
                val amountText = bottomSheetBinding.etAmount.text.toString()
                if (amountText.isNotEmpty()) {
                    val amount = amountText.toDoubleOrNull()
                    if (amount != null && amount > 0) {
                        // Show payment method selection toast for now
                        showToast("Processing payment via $selectedPaymentMethod...")
                        processTopUp(amount)
                        bottomSheetDialog.dismiss()
                    } else {
                        showToast("Please enter a valid amount")
                    }
                }
            }
            
            // Initialize with UPI selected
            selectPaymentMethod(bottomSheetBinding, "UPI")
            
            android.util.Log.d("WalletFragmentNew", "About to show bottom sheet")
            bottomSheetDialog.show()
            android.util.Log.d("WalletFragmentNew", "Bottom sheet shown")
            
        } catch (e: Exception) {
            android.util.Log.e("WalletFragmentNew", "Error showing bottom sheet", e)
            showToast("Error opening top-up dialog: ${e.message}")
        }
    }
    
    private fun selectPaymentMethod(binding: BottomSheetTopUpSimpleBinding, method: String) {
        // Reset all radio buttons (only UPI and Card now)
        binding.radioUpi.isChecked = false
        binding.radioCard.isChecked = false
        
        // Select the chosen method
        when (method) {
            "UPI" -> binding.radioUpi.isChecked = true
            "CARD" -> binding.radioCard.isChecked = true
        }
    }
    
    private fun updateAddButtonState(binding: BottomSheetTopUpSimpleBinding) {
        val amountText = binding.etAmount.text.toString()
        val amount = amountText.toDoubleOrNull()
        val isValidAmount = amount != null && amount > 0
        
        binding.btnAddMoneyConfirm.isEnabled = isValidAmount
        binding.btnAddMoneyConfirm.text = if (isValidAmount) {
            "Add ₹${amount?.toInt()}"
        } else {
            "Add Money"
        }
    }
    
    private fun processTopUp(amount: Double) {
        val userId = getUserId()
        if (userId == null) {
            showToast("Please login to add money")
            return
        }

        // Show loading
        binding.progressLoading.visibility = View.VISIBLE

        lifecycleScope.launch {
            try {
                // Call the top-up API
                val response = ApiClient.apiService.topUpWallet(
                    userId = userId,
                    request = mapOf("amount" to amount)
                )

                if (response.isSuccessful) {
                    // Update balance immediately for better UX
                    currentBalance += amount
                    updateBalanceDisplay()
                    
                    // Add the transaction to the list with current timestamp
                    val newTransaction = Transaction(
                        id = "TXN${System.currentTimeMillis()}",
                        type = TransactionType.TOP_UP,
                        amount = amount,
                        description = "Wallet Top-up - ₹${amount.toInt()}",
                        timestamp = Date(), // This ensures current date/time
                        balanceAfter = currentBalance
                    )
                    
                    // Add to beginning and re-sort to maintain order
                    userTransactions.add(0, newTransaction)
                    userTransactions.sortByDescending { it.timestamp }
                    updateTransactionsDisplay()
                    
                    showToast("₹${amount.toInt()} added successfully!")
                    
                    // Reload wallet data to get updated info from server (this will refresh with server data)
                    loadWalletData()
                } else {
                    showToast("Failed to add money. Please try again.")
                }
            } catch (e: Exception) {
                showToast("Error: ${e.message}")
            } finally {
                binding.progressLoading.visibility = View.GONE
            }
        }
    }

    override fun scrollToTop() {
        try {
            binding.scrollContent.smoothScrollTo(0, 0)
        } catch (e: Exception) {
            // Handle any exceptions
        }
    }

    private fun loadUserName() {
        val sharedPref = requireActivity().getSharedPreferences("gridee_prefs", android.content.Context.MODE_PRIVATE)
        val userName = sharedPref.getString("user_name", "USER NAME") ?: "USER NAME"
        
        // Update the credit card with user's name (convert to uppercase for consistency)
        binding.tvCardholderName.text = userName.uppercase()
    }

    private fun getUserId(): String? {
        val sharedPref = requireActivity().getSharedPreferences("gridee_prefs", android.content.Context.MODE_PRIVATE)
        return sharedPref.getString("user_id", null)
    }
}
