package com.gridee.parking.ui.fragments

import android.animation.ObjectAnimator
import android.animation.ValueAnimator
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.view.animation.OvershootInterpolator
import android.widget.TextView
import androidx.core.animation.doOnEnd
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import com.gridee.parking.R
import com.gridee.parking.data.api.ApiClient
import com.gridee.parking.data.model.Booking as BackendBooking
import com.gridee.parking.databinding.FragmentBookingsNewBinding
import com.gridee.parking.ui.adapters.Booking
import com.gridee.parking.ui.adapters.BookingStatus
import com.gridee.parking.ui.adapters.BookingsAdapter
import com.gridee.parking.ui.base.BaseTabFragment
import com.gridee.parking.ui.components.BookingDetailsBottomSheetSimple
import com.gridee.parking.ui.components.EnhancedSegmentedControlGestureHandler
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*

class BookingsFragmentNew : BaseTabFragment<FragmentBookingsNewBinding>() {

    private lateinit var bookingsAdapter: BookingsAdapter
    private var userBookings = mutableListOf<Booking>()
    private var currentTab = BookingStatus.ACTIVE
    private lateinit var gestureHandler: EnhancedSegmentedControlGestureHandler

    override fun getViewBinding(inflater: LayoutInflater, container: ViewGroup?): FragmentBookingsNewBinding {
        return FragmentBookingsNewBinding.inflate(inflater, container, false)
    }

    override fun getScrollableView(): View? {
        return try {
            binding.rvBookings
        } catch (e: IllegalStateException) {
            null
        }
    }

    override fun setupUI() {
        setupRecyclerView()
        setupSegmentedControl()
        setupEnhancedGestureHandler()
        loadBookingsFromAPI()
    }

    private fun setupRecyclerView() {
        val statuses = listOf(BookingStatus.ACTIVE, BookingStatus.PENDING, BookingStatus.COMPLETED)
        currentTab = statuses.first()

        bookingsAdapter = BookingsAdapter(mutableListOf()) { booking ->
            showToast("Booking clicked: ${booking.title}")
        }
        binding.rvBookings.apply {
            layoutManager = LinearLayoutManager(requireContext())
            adapter = bookingsAdapter
        }
    }

    private fun setupSegmentedControl() {
        // Reset segment visibility
        binding.segmentedControlContainer.segmentActive.visibility = View.VISIBLE
        binding.segmentedControlContainer.segmentPending.visibility = View.VISIBLE
        binding.segmentedControlContainer.segmentCompleted.visibility = View.VISIBLE

        // Set initial selection
        binding.segmentedControlContainer.textActive.setTextColor(resources.getColor(R.color.white, null))
        binding.segmentedControlContainer.textPending.setTextColor(resources.getColor(R.color.bulky_glass_unselected_text, null))
        binding.segmentedControlContainer.textCompleted.setTextColor(resources.getColor(R.color.bulky_glass_unselected_text, null))
        
        // Set current tab
        currentTab = BookingStatus.ACTIVE
    }

    private fun setupEnhancedGestureHandler() {
        gestureHandler = EnhancedSegmentedControlGestureHandler(
            context = requireContext(),
            containerView = binding.segmentedControlContainer.segmentContainer,
            indicatorView = binding.segmentedControlContainer.segmentIndicator,
            segments = listOf(binding.segmentedControlContainer.segmentActive, binding.segmentedControlContainer.segmentPending, binding.segmentedControlContainer.segmentCompleted),
            onSelectionChanged = { selectedIndex ->
                handleSegmentSelection(selectedIndex)
                // Accessibility announcement
                val segmentText = when (selectedIndex) {
                    0 -> "Active"
                    1 -> "Pending" 
                    2 -> "Completed"
                    else -> "Unknown"
                }
                binding.root.announceForAccessibility("$segmentText segment selected")
            }
        )
    }

    override fun onDestroyView() {
        gestureHandler?.cleanup()
        super.onDestroyView()
    }

    private fun getSegmentTitle(status: BookingStatus): String {
        return when (status) {
            BookingStatus.ACTIVE -> binding.segmentedControlContainer.textActive.text.toString()
            BookingStatus.PENDING -> binding.segmentedControlContainer.textPending.text.toString()
            BookingStatus.COMPLETED -> binding.segmentedControlContainer.textCompleted.text.toString()
        }
    }

    private fun updateSegmentTabs(selectedStatus: BookingStatus) {
        when (selectedStatus) {
            BookingStatus.ACTIVE -> {
                binding.segmentedControlContainer.textActive.setTextColor(resources.getColor(R.color.white, null))
                binding.segmentedControlContainer.textPending.setTextColor(resources.getColor(R.color.bulky_glass_unselected_text, null))
                binding.segmentedControlContainer.textCompleted.setTextColor(resources.getColor(R.color.bulky_glass_unselected_text, null))
            }
            BookingStatus.PENDING -> {
                binding.segmentedControlContainer.textActive.setTextColor(resources.getColor(R.color.bulky_glass_unselected_text, null))
                binding.segmentedControlContainer.textPending.setTextColor(resources.getColor(R.color.white, null))
                binding.segmentedControlContainer.textCompleted.setTextColor(resources.getColor(R.color.bulky_glass_unselected_text, null))
            }
            BookingStatus.COMPLETED -> {
                binding.segmentedControlContainer.textActive.setTextColor(resources.getColor(R.color.bulky_glass_unselected_text, null))
                binding.segmentedControlContainer.textPending.setTextColor(resources.getColor(R.color.bulky_glass_unselected_text, null))
                binding.segmentedControlContainer.textCompleted.setTextColor(resources.getColor(R.color.white, null))
            }
        }

        currentTab = selectedStatus
    }

    private fun animateTextColor(textView: TextView, isSelected: Boolean) {
        val fromColor = textView.currentTextColor
        val toColor = if (isSelected) {
            ValueAnimator.ofArgb(fromColor, resources.getColor(R.color.white, null))
        } else {
            ValueAnimator.ofArgb(fromColor, resources.getColor(R.color.bulky_glass_unselected_text, null))
        }
        toColor.duration = 240
        toColor.addUpdateListener { animation ->
            textView.setTextColor(animation.animatedValue as Int)
        }
        toColor.start()
    }

    private fun animateTextScale(textView: TextView, isSelected: Boolean) {
        ObjectAnimator.ofFloat(textView, "scaleX", if (isSelected) 1.05f else 1.0f).apply {
            duration = 180
            start()
        }
        ObjectAnimator.ofFloat(textView, "scaleY", if (isSelected) 1.05f else 1.0f).apply {
            duration = 180
            start()
        }
    }

    private fun animateTextAlpha(textView: TextView, isSelected: Boolean) {
        ObjectAnimator.ofFloat(textView, "alpha", if (isSelected) 1.0f else 0.7f).apply {
            duration = 160
            start()
        }
        ObjectAnimator.ofFloat(textView, "alpha", if (isSelected) 1.0f else 0.7f).apply {
            duration = 160
            start()
        }
    }

    private fun filterBookingsByStatus(status: BookingStatus) {
        val filteredBookings = userBookings.filter { it.status == status }
        bookingsAdapter.updateBookings(filteredBookings)

        // Update visibility
        binding.rvBookings.visibility = if (filteredBookings.isEmpty()) View.GONE else View.VISIBLE
        binding.layoutEmptyState.visibility = if (filteredBookings.isEmpty()) View.VISIBLE else View.GONE
    }

    private fun handleSegmentSelection(index: Int) {
        val newStatus = when (index) {
            0 -> BookingStatus.ACTIVE
            1 -> BookingStatus.PENDING
            2 -> BookingStatus.COMPLETED
            else -> BookingStatus.ACTIVE
        }
        
        if (newStatus != currentTab) {
            showToast("Switched to ${getSegmentTitle(newStatus)}")
            currentTab = newStatus
            filterBookingsByStatus(newStatus)
        }
    }

    private fun loadBookingsFromAPI() {
        lifecycleScope.launch {
            try {
                val userID = ApiClient.getCurrentUserID()
                if (userID.isNotEmpty()) {
                    val response = ApiClient.instance.getUserBookings(userID)
                    if (response.isSuccessful) {
                        response.body()?.let { backendBookings ->
                            val mappedBookings = backendBookings.map { backendBooking ->
                                mapBackendBookingToUI(backendBooking)
                            }
                            userBookings.clear()
                            userBookings.addAll(mappedBookings)
                            filterBookingsByStatus(currentTab)
                        }
                    } else {
                        showToast("Failed to load bookings")
                    }
                } else {
                    showToast("User not logged in")
                }
            } catch (e: Exception) {
                showToast("Error: ${e.message}")
                binding.emptyStateLayout.visibility = View.VISIBLE
            }
        }
    }

    private fun generateSampleBookings(): List<Booking> {
        return listOf(
            Booking(
                id = "1",
                title = "Sample Active Booking",
                location = "Sample Location",
                price = "$5.00",
                duration = "2 hours",
                timeRange = "10:00 AM - 12:00 PM",
                date = "Today",
                status = BookingStatus.ACTIVE
            ),
            Booking(
                id = "2", 
                title = "Sample Upcoming Booking",
                location = "Sample Location 2",
                price = "$8.00", 
                duration = "3 hours",
                timeRange = "2:00 PM - 5:00 PM",
                date = "Tomorrow",
                status = BookingStatus.UPCOMING
            ),
            Booking(
                id = "3",
                title = "Sample Completed Booking",
                location = "Sample Location 3", 
                price = "$6.00",
                duration = "1 hour",
                timeRange = "9:00 AM - 10:00 AM",
                date = "Yesterday",
                status = BookingStatus.COMPLETED
            )
        )
    }

    private fun mapBackendBookingToUI(backendBooking: BackendBooking): Booking {
        val inputDateFormat = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.getDefault())
        val outputDateFormat = SimpleDateFormat("MMM dd", Locale.getDefault())

        try {
            val startDate = inputDateFormat.parse(backendBooking.startTime)
            val endDate = inputDateFormat.parse(backendBooking.endTime)

            val duration = if (startDate != null && endDate != null) {
                val durationMillis = endDate.time - startDate.time
                val hours = durationMillis / (1000 * 60 * 60)
                val minutes = (durationMillis % (1000 * 60 * 60)) / (1000 * 60)
                when {
                    hours > 0 && minutes > 0 -> "${hours}h ${minutes}m"
                    hours > 0 -> "${hours}h"
                    else -> "${minutes}m"
                }
            } else "Unknown"

            val timeRange = if (startDate != null && endDate != null) {
                val timeFormat = SimpleDateFormat("h:mm a", Locale.getDefault())
                "${timeFormat.format(startDate)} - ${timeFormat.format(endDate)}"
            } else "Unknown"

            val date = startDate?.let { outputDateFormat.format(it) } ?: "Unknown"

            val status = determineStatus(backendBooking.isActive, Date(), startDate, endDate)

            return Booking(
                id = backendBooking.id,
                title = backendBooking.parkingLocation?.name ?: "Unknown Location",
                location = "${backendBooking.parkingLocation?.address ?: "Unknown Address"}",
                price = "$${backendBooking.totalCost}",
                duration = duration,
                timeRange = timeRange,
                date = date,
                status = status
            )
        } catch (e: Exception) {
            return Booking(
                id = backendBooking.id,
                title = "Error Loading Booking",
                location = "Unknown",
                price = "$0.00",
                duration = "Unknown",
                timeRange = "Unknown",
                date = "Unknown",
                status = BookingStatus.COMPLETED
            )
        }
    }

    private fun determineStatus(isActive: Boolean, currentTime: Date, startTime: Date?, endTime: Date?): BookingStatus {
        return when {
            startTime == null || endTime == null -> BookingStatus.COMPLETED
            isActive && currentTime.after(startTime) && currentTime.before(endTime) -> BookingStatus.ACTIVE
            currentTime.before(startTime) -> BookingStatus.UPCOMING
            currentTime.after(endTime) -> BookingStatus.COMPLETED
            else -> BookingStatus.COMPLETED
        }
    }

    private fun onBookingClicked(booking: Booking) {
        val bottomSheet = BookingDetailsBottomSheetSimple.newInstance(booking)
        bottomSheet.show(parentFragmentManager, "BookingDetailsBottomSheet")
    }

    override fun scrollToTop() {
        try {
            binding.rvBookings.smoothScrollToPosition(0)
        } catch (e: IllegalStateException) {
            // Handle case where fragment is not attached
        }
    }

    override fun onResume() {
        super.onResume()
        requireActivity().title = "My Bookings"
    }
}
            showToast("Booking: ${booking.id}")
        }
        
        binding.rvBookings.apply {
            layoutManager = LinearLayoutManager(requireContext())
            adapter = bookingsAdapter
        }
    }

    private fun setupSegmentedControl() {
        // Wait for views to be laid out before setting up gesture handler
        binding.segmentedControlContainer.segmentContainer.post {
            setupEnhancedGestureHandler()
            initializeSegmentedControlState()
        }
    }
    
    /**
     * Setup the enhanced gesture handler with tap and drag support
     */
    private fun setupEnhancedGestureHandler() {
        val segments = listOf(
            binding.segmentedControlContainer.segmentActive,
            binding.segmentedControlContainer.segmentPending,
            binding.segmentedControlContainer.segmentCompleted
        )
        
        gestureHandler = EnhancedSegmentedControlGestureHandler(
            context = requireContext(),
            containerView = binding.segmentedControlContainer.segmentContainer,
            indicatorView = binding.segmentedControlContainer.segmentIndicator,
            segments = segments,
            onSelectionChanged = { index ->
                handleSegmentSelection(index)
            },
            onAccessibilityAnnouncement = { message ->
                announceForAccessibility(message)
            }
        )
        
        // Set initial selection to pending (index 1)
        gestureHandler.setSelectedIndex(1, animated = false)
    }
    
    /**
     * Initialize segmented control visual state
     */
    private fun initializeSegmentedControlState() {
        // Set initial indicator width and position for pending segment
        val pendingSegment = binding.segmentedControlContainer.segmentPending
        val segmentWidth = pendingSegment.width - 16 // Account for 8dp margins on each side
        val layoutParams = binding.segmentedControlContainer.segmentIndicator.layoutParams
        layoutParams.width = segmentWidth
        binding.segmentedControlContainer.segmentIndicator.layoutParams = layoutParams
        
        // Position indicator at pending segment
        val pendingX = pendingSegment.x + 8f // Add 8dp margin
        binding.segmentedControlContainer.segmentIndicator.x = pendingX
        
        // Set initial text colors
        updateSegmentTextColors(BookingStatus.PENDING)
    }
    
    /**
     * Handle segment selection from gesture handler
     */
    private fun handleSegmentSelection(index: Int) {
        val newStatus = when (index) {
            0 -> BookingStatus.ACTIVE
            1 -> BookingStatus.PENDING
            2 -> BookingStatus.COMPLETED
            else -> BookingStatus.PENDING
        }
        
        if (currentTab != newStatus) {
            currentTab = newStatus
            updateSegmentTextColors(newStatus)
            showBookingsForStatus(newStatus)
        }
    }

    override fun onDestroyView() {
        if (::gestureHandler.isInitialized) {
            gestureHandler.cleanup()
        }
        super.onDestroyView()
    }

    private fun updateSegmentTextColors(selectedStatus: BookingStatus) {
        // Enhanced cross-fade animation for text color transitions (140ms as specified)
        val fadeDuration = 140L
        
        // Reset all to unselected color with fade animation
        animateTextColor(binding.segmentedControlContainer.textActive, resources.getColor(R.color.bulky_glass_text_unselected, null), fadeDuration)
        animateTextColor(binding.segmentedControlContainer.textPending, resources.getColor(R.color.bulky_glass_text_unselected, null), fadeDuration)
        animateTextColor(binding.segmentedControlContainer.textCompleted, resources.getColor(R.color.bulky_glass_text_unselected, null), fadeDuration)

        // Set selected to primary color with fade animation
        when (selectedStatus) {
            BookingStatus.ACTIVE -> {
                animateTextColor(binding.segmentedControlContainer.textActive, resources.getColor(R.color.bulky_glass_text_selected, null), fadeDuration)
                // Optional subtle scale effect for selected text
                animateTextScale(binding.segmentedControlContainer.textActive, 1.02f, fadeDuration)
                resetTextScale(binding.segmentedControlContainer.textPending, fadeDuration)
                resetTextScale(binding.segmentedControlContainer.textCompleted, fadeDuration)
            }
            BookingStatus.PENDING -> {
                animateTextColor(binding.segmentedControlContainer.textPending, resources.getColor(R.color.bulky_glass_text_selected, null), fadeDuration)
                animateTextScale(binding.segmentedControlContainer.textPending, 1.02f, fadeDuration)
                resetTextScale(binding.segmentedControlContainer.textActive, fadeDuration)
                resetTextScale(binding.segmentedControlContainer.textCompleted, fadeDuration)
            }
            BookingStatus.COMPLETED -> {
                animateTextColor(binding.segmentedControlContainer.textCompleted, resources.getColor(R.color.bulky_glass_text_selected, null), fadeDuration)
                animateTextScale(binding.segmentedControlContainer.textCompleted, 1.02f, fadeDuration)
                resetTextScale(binding.segmentedControlContainer.textActive, fadeDuration)
                resetTextScale(binding.segmentedControlContainer.textPending, fadeDuration)
            }
        }
    }

    private fun animateTextColor(textView: TextView, targetColor: Int, duration: Long) {
        val currentColor = textView.currentTextColor
        val colorAnimator = ValueAnimator.ofArgb(currentColor, targetColor).apply {
            this.duration = duration
            addUpdateListener { animator ->
                textView.setTextColor(animator.animatedValue as Int)
            }
        }
        colorAnimator.start()
    }

    private fun animateTextScale(textView: TextView, targetScale: Float, duration: Long) {
        ObjectAnimator.ofFloat(textView, "scaleX", targetScale).apply {
            this.duration = duration
            start()
        }
        ObjectAnimator.ofFloat(textView, "scaleY", targetScale).apply {
            this.duration = duration
            start()
        }
    }

    private fun resetTextScale(textView: TextView, duration: Long) {
        ObjectAnimator.ofFloat(textView, "scaleX", 1.0f).apply {
            this.duration = duration
            start()
        }
        ObjectAnimator.ofFloat(textView, "scaleY", 1.0f).apply {
            this.duration = duration
            start()
        }
    }

    private fun showBookingsForStatus(status: BookingStatus) {
        val filteredBookings = userBookings.filter { it.status == status }
        
        if (filteredBookings.isEmpty()) {
            // Show empty state
            binding.rvBookings.visibility = View.GONE
            binding.layoutEmptyState.visibility = View.VISIBLE
            
            // Update empty state text based on status
            when (status) {
                BookingStatus.ACTIVE -> {
                    binding.tvEmptyTitle.text = "No Active Bookings"
                    binding.tvEmptySubtitle.text = "Your active parking bookings will appear here"
                }
                BookingStatus.PENDING -> {
                    binding.tvEmptyTitle.text = "No Pending Bookings"
                    binding.tvEmptySubtitle.text = "Your pending bookings will appear here"
                }
                BookingStatus.COMPLETED -> {
                    binding.tvEmptyTitle.text = "No Completed Bookings"
                    binding.tvEmptySubtitle.text = "Your booking history will appear here"
                }
            }
        } else {
            // Show bookings list
            binding.rvBookings.visibility = View.VISIBLE
            binding.layoutEmptyState.visibility = View.GONE
            bookingsAdapter.updateBookings(filteredBookings)
        }
    }

    private fun loadUserBookings() {
        binding.progressLoading.visibility = View.VISIBLE
        
        val userId = getUserId()
        if (userId == null) {
            showToast("Please login to view your bookings")
            binding.progressLoading.visibility = View.GONE
            // Show empty state
            showBookingsForStatus(currentTab)
            return
        }
        
        lifecycleScope.launch {
            try {
                // Get user bookings from backend using real user ID
                val response = ApiClient.apiService.getUserBookings(userId)
                
                if (response.isSuccessful) {
                    val backendBookings = response.body() ?: emptyList()
                    
                    // Convert backend bookings to UI bookings
                    userBookings.clear()
                    userBookings.addAll(backendBookings.map { convertToUIBooking(it) })
                    
                    // Update UI for current tab
                    showBookingsForStatus(currentTab)
                } else {
                    // Handle API error - for development, show sample data if no real bookings
                    showToast("Server error: ${response.code()} - ${response.message()}")
                    // For production, you might want to show empty state instead of sample data
                    if (response.code() == 404) {
                        // No bookings found - show empty state
                        userBookings.clear()
                        showBookingsForStatus(currentTab)
                    } else {
                        // Other server errors - show sample data for testing
                        loadSampleBookings()
                    }
                }
                
            } catch (e: Exception) {
                // Handle error - for development, show sample data
                showToast("Network error: ${e.message}")
                loadSampleBookings()
            } finally {
                binding.progressLoading.visibility = View.GONE
            }
        }
    }

    private fun loadSampleBookings() {
        // NOTE: This is fallback sample data shown only when:
        // 1. User is not logged in, OR
        // 2. API call fails due to network/server errors
        // In normal operation, real user bookings from the backend are displayed
        
        // Create sample bookings for demonstration
        val sampleBookings = listOf(
            Booking(
                id = "BK001",
                vehicleNumber = "MH01AB1234",
                spotId = "A-12",
                spotName = "A-12",
                locationName = "Downtown Mall Parking",
                locationAddress = "123 Main Street",
                startTime = "09:00 AM",
                endTime = "06:00 PM",
                duration = "9h 0m",
                amount = "₹150.00",
                bookingDate = "Today",
                status = BookingStatus.ACTIVE
            ),
            Booking(
                id = "BK002",
                vehicleNumber = "MH01AB1234",
                spotId = "B-05",
                spotName = "B-05",
                locationName = "Office Complex",
                locationAddress = "456 Business District",
                startTime = "08:30 AM",
                endTime = "05:30 PM",
                duration = "9h 0m",
                amount = "₹200.00",
                bookingDate = "Yesterday",
                status = BookingStatus.COMPLETED
            ),
            Booking(
                id = "BK003",
                vehicleNumber = "MH01AB1234",
                spotId = "C-08",
                spotName = "C-08",
                locationName = "Shopping Center",
                locationAddress = "789 Retail Plaza",
                startTime = "02:00 PM",
                endTime = "11:00 PM",
                duration = "9h 0m",
                amount = "₹180.00",
                bookingDate = "Tomorrow",
                status = BookingStatus.PENDING
            )
        )
        
        userBookings.clear()
        userBookings.addAll(sampleBookings)
        showBookingsForStatus(currentTab)
    }

    private fun convertToUIBooking(backendBooking: BackendBooking): Booking {
        val dateFormat = SimpleDateFormat("MMM dd, yyyy", Locale.getDefault())
        val timeFormat = SimpleDateFormat("hh:mm a", Locale.getDefault())
        
        // Generate better parking location names based on lot ID
        val parkingLocation = when (backendBooking.lotId) {
            "1", "101" -> "City Mall Parking"
            "2", "102" -> "Airport Terminal"
            "3", "103" -> "Shopping Center"
            "4", "104" -> "Business District"
            "5", "105" -> "Metro Station"
            else -> "Parking Lot ${backendBooking.lotId}"
        }
        
        // Generate better spot names
        val spotName = when {
            backendBooking.spotId?.toIntOrNull() != null -> {
                val spotNum = backendBooking.spotId.toInt()
                when {
                    spotNum <= 20 -> "A-${spotNum}"
                    spotNum <= 40 -> "B-${spotNum - 20}"
                    spotNum <= 60 -> "C-${spotNum - 40}"
                    else -> "D-${spotNum - 60}"
                }
            }
            else -> backendBooking.spotId ?: "Unknown"
        }
        
        return Booking(
            id = backendBooking.id ?: "Unknown",
            vehicleNumber = backendBooking.vehicleNumber ?: "Vehicle not specified",
            spotId = backendBooking.spotId ?: "Unknown", // Keep original spot ID
            spotName = spotName, // Use the formatted spot name
            locationName = parkingLocation, // Use the formatted location name
            locationAddress = "Location for ${parkingLocation}", // Enhanced address
            startTime = if (backendBooking.checkInTime != null) timeFormat.format(backendBooking.checkInTime) else "Not started",
            endTime = if (backendBooking.checkOutTime != null) timeFormat.format(backendBooking.checkOutTime) else "TBD",
            duration = calculateDuration(backendBooking.checkInTime, backendBooking.checkOutTime),
            amount = "₹${String.format("%.2f", backendBooking.amount)}",
            bookingDate = if (backendBooking.createdAt != null) dateFormat.format(backendBooking.createdAt) else "Unknown",
            status = mapBackendStatus(backendBooking.status)
        )
    }

    private fun calculateDuration(startTime: Date?, endTime: Date?): String {
        if (startTime == null || endTime == null) return "N/A"
        
        val durationMs = endTime.time - startTime.time
        val hours = durationMs / (1000 * 60 * 60)
        val minutes = (durationMs % (1000 * 60 * 60)) / (1000 * 60)
        
        return "${hours}h ${minutes}m"
    }

    private fun mapBackendStatus(backendStatus: String?): BookingStatus {
        return when (backendStatus?.lowercase()) {
            "active", "confirmed" -> BookingStatus.ACTIVE
            "pending", "created" -> BookingStatus.PENDING
            "completed", "finished", "cancelled" -> BookingStatus.COMPLETED
            else -> BookingStatus.PENDING
        }
    }

    private fun showBookingDetails(booking: Booking) {
        // Create and show bottom sheet with booking details
        val bottomSheet = BookingDetailsBottomSheetSimple.newInstance(booking)
        bottomSheet.show(parentFragmentManager, "BookingDetailsBottomSheet")
    }

    override fun scrollToTop() {
        try {
            binding.rvBookings.smoothScrollToPosition(0)
        } catch (e: Exception) {
            // Handle any exceptions
        }
    }

    private fun getUserId(): String? {
        val sharedPref = requireActivity().getSharedPreferences("gridee_prefs", android.content.Context.MODE_PRIVATE)
        return sharedPref.getString("user_id", null)
    }
}
